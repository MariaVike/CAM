module gw_chem

!
! This module contains code to compute the wave‚Äêdriven constituent transport 
! due to non-breaking gravity waves (Gardner et al, ESS, 2019 ; Gardner et al, JGR, 2018).
! Here we compute the effective wave diffusivity (K_wave) as a function of the 
! eddy diffusivity (Kzz) and of thevariances of the temperature and lapse rate fluctuations
!

use gw_utils,     only: r8
use coords_1d,    only: Coords1D
use spmd_utils,   only: masterproc
use cam_logfile,  only: iulog
use ref_pres,     only: pref_edge

implicit none
private
save

! Public interface.
public :: effective_gw_diffusivity

contains

!==========================================================================

subroutine effective_gw_diffusivity (ncol, band, lambda_h, p, dt,    &
           t, rhoi, nm, ni, c_speed, tau, egwdffi, ubi, k_wave, xi, k_e,  & 
           zm, zi, var_t, dtdz, brnt_v, lat, lon, kwvrdg)
!-----------------------------------------------------------------------
! Compute K_wave (wave effective diffusivity) etc...
! ....
!-----------------------------------------------------------------------
use gw_common, only: GWBand, pver, pi
use physconst, only: cpair, cpairv, gravit
use gw_utils, only: midpoint_interp
!------------------------------Arguments--------------------------------
  ! Column dimension.
  integer, intent(in) :: ncol
  ! band of phase speeds c within whic waves are emitted
  type(GWBand), intent(in) :: band
  ! horizonatl wavelength
  real(r8), intent(in) :: lambda_h
  ! horiz wavenumber [anisotropic orography].
  real(r8), intent(in), optional :: kwvrdg(ncol)
  ! Pressure coordinates.
  type(Coords1D), intent(in) :: p
  ! Time step.
  real(r8), intent(in) :: dt
  ! Midpoint temperature.
  real(r8), intent(in) :: t(ncol,pver)
  ! Interface density (Kg m-3)
  real(r8), intent(in) :: rhoi(ncol,pver+1)
  ! Midpoint and interface Brunt-Vaisala frequencies.
  real(r8), intent(in) :: nm(ncol,pver), ni(ncol,pver+1)
  ! Projection of wind at interfaces.
  real(r8), intent(in) :: ubi(ncol,pver+1)
  ! Wave phase speeds for each column.
  real(r8), intent(in) :: c_speed(ncol,-band%ngwv:band%ngwv)
  ! Wave Reynolds stress.
  real(r8), intent(in) :: tau(ncol,-band%ngwv:band%ngwv,pver+1)
  ! Effective gravity wave diffusivity at interfaces.
  real(r8), intent(in) :: egwdffi(ncol,pver+1)
  ! Midpoint and Interface altitudes above ground (m).
  real(r8), intent(in) :: zm(ncol,pver), zi(ncol,pver+1)    
  ! Latitude in radians.
  real(r8), intent(in) :: lat(:)
  ! Longitude in radians.
  real(r8), intent(in) :: lon(:)


  real(r8), intent(out) :: k_wave(ncol,pver) !total over entire wave spectrum for each GW source
  real(r8), intent(out) :: xi(ncol,pver)
  real(r8), intent(out) :: k_e(ncol,pver)

  ! Variance of T'
  real(r8), intent(out)  :: var_t(ncol,pver)
  ! Dt/Dz environment 
  real(r8), intent(out)  :: dtdz(ncol, pver)
  ! Interface Brunt-Vaisala frequency computed locally.
  real(r8), intent (out) :: brnt_v(ncol,pver)

  
  !---------------------------Local storage-------------------------------

  ! Level, wavenumber, and column loop indices.
  integer  :: k, l, i
  real(r8) :: icount, times
  ! Bottom level for computation of k_wave
  integer  :: kwave_level
  ! Gas consant for dry air (m2 K-1 s-2)
  real(r8), parameter :: R_air = 287._r8
  ! Adiabatic lapse rate and R/cp ratio
  real(r8) :: gamma_ad, cp_r 
  ! Interface temperature.
  real(r8) :: ti(ncol,pver+1)
  ! The absolute momenum flux computed from tau
  real(r8) :: mom_flux(ncol,-band%ngwv:band%ngwv,pver+1)
  ! Wave Reynolds stress damped.
  real(r8) :: tau_dmp(ncol,-band%ngwv:band%ngwv,pver+1)
  ! Damping factor for tau profile
  real(r8) :: lambda_wave(ncol,-band%ngwv:band%ngwv,pver)
  ! Delta z computed across interfaces 
  real(r8) :: delta_z(ncol, pver+1)
  !convert degrees to radians
  real(r8), parameter :: degree_radian = pi/180._r8
  !convert hours to seconds
  real(r8), parameter :: hr_sec = 3600._r8
  !Coriolis frequency and inertial period
  real(r8) :: coriolis_f(size(lat)), inertial_prd(size(lat))
  ! Interface Brunt-Vaisala frequency squared computed locally.
  real(r8) :: brnt_v_sq(ncol,pver)
  ! Min value for Brunt_vaisala frequenncy squared
  real(r8), parameter :: brnt_v_sq_min = 5.e-5_r8
  ! Environmental lapse-rate: -dT/dz
  real(r8) :: gamma_env(ncol,pver)


 !compute adiabatic lapse rate(K/m) and R/Cp ratio
 gamma_ad=gravit/cpair
 cp_r= cpair/R_air
 !compute temperature at interface (call function)
 ti(:,2:pver)=midpoint_interp(t)

 !Compute Brunt_vaisala freq at interfaces using mid-poit temperatures (s-1)
   do k = pver-1,1,-1
      dtdz(:,k)=(t(:,k)-t(:,k+1))/(zm(:,k)-zm(:,k+1)) 
      gamma_env(:,k)=-dtdz(:,k)
      brnt_v_sq(:,k)=gravit/ti(:,k+1)*(gamma_ad - gamma_env(:,k))
      brnt_v(:,k)=(max(brnt_v_sq_min, brnt_v_sq(:,k)))**0.5
   enddo

 !Compute the coriolis frequency (rad/s) and set it to 2pi/24h for equatorial regions
  where (abs(lat) <= 30._r8*degree_radian)
   coriolis_f=(2._r8*pi)/(24._r8*hr_sec)
  elsewhere
   coriolis_f=abs( (2._r8*pi*sin(lat))/(12._r8*hr_sec) )
  end where
  !Compute inertial period (s)
  inertial_prd= 2._r8*pi/coriolis_f

  !Compute Delta_z for heights >= kwave_level to use later for calculations of tau_dmp
   do k = pver,1,-1 ! or:  kwave_level-1,1,-1
      delta_z(:,k)=zi(:,k)-zi(:,k+1) !we are at interfaces so start from pver instead of pver+1  			            
   enddo   

 !Compute Dt/Dz (K/m) for later computation of Var(T)
   do k =  pver-1,1,-1 !!NB midpoint array length is pver / or: kwave_level-2,1,-1 midpoint arrays are always -1 shorter than interface
      dtdz(:,k)=(t(:,k)-t(:,k+1))/(zm(:,k)-zm(:,k+1)) !we are using t at mid-points so dtdz is computed at interfaces
   enddo 
 
  !Find lowest level for computation of k_wave
  do k=1,pver+1
     if (pref_edge(k) .lt. 100._r8) then !below 1hPa ~ 50km
       kwave_level=k
     endif
  enddo

 !Compute momentum flux MF (m2/s2) from the wave stress tau (Pa) and damp it above 50km
 DO k = kwave_level-1, 2, -1 !disregard first and last (kwave_level) interface values, the rest of variables are defined with 
			     !centred differences of mid-points values

  IF (k .eq. kwave_level-1) THEN

     do l = -band%ngwv, band%ngwv
         mom_flux(:,l,k)=tau(:,l,k)/rhoi(:,k)
     enddo
     
        ! compute k_wave with un-damped tau at first level 
        if (present(kwvrdg)) then          
  		call compute_kwave (ncol, band, lambda_h, ti(:,k), rhoi(:,k), brnt_v(:,k-1), egwdffi(:,k),     &
           	     cp_r, gamma_ad, coriolis_f, inertial_prd, c_speed, ubi(:,k), mom_flux(:,:,k), kwave_level,  &
           	     dtdz(:,k-1), var_t(:,k), k_e(:,k), xi(:,k), k_wave(:,k), lambda_wave(:,:,k), kwvrdg=kwvrdg)      
 	else
  		call compute_kwave (ncol, band, lambda_h, ti(:,k), rhoi(:,k), brnt_v(:,k-1), egwdffi(:,k),     &
           	     cp_r, gamma_ad, coriolis_f, inertial_prd, c_speed, ubi(:,k), mom_flux(:,:,k), kwave_level,  &
           	     dtdz(:,k-1), var_t(:,k), k_e(:,k), xi(:,k), k_wave(:,k), lambda_wave(:,:,k)) 
 	endif

 ELSE
  
     !damp tau using k_wave value just calculated 
      do l = -band%ngwv, band%ngwv
	 tau_dmp(:,l,k)=tau(:,l,k)*exp(-2.*lambda_wave(:,l,k+1)*delta_z(:,k)) !damp tau using lambda_wave values from level below
         mom_flux(:,l,k)=tau_dmp(:,l,k)/rhoi(:,k) 
      enddo

	 !compute k_wave using damped tau values
        if (present(kwvrdg)) then          
  		call compute_kwave (ncol, band, lambda_h, ti(:,k), rhoi(:,k), brnt_v(:,k-1), egwdffi(:,k),     &
           	     cp_r, gamma_ad, coriolis_f, inertial_prd, c_speed, ubi(:,k), mom_flux(:,:,k), kwave_level,  &
           	     dtdz(:,k-1), var_t(:,k), k_e(:,k), xi(:,k), k_wave(:,k), lambda_wave(:,:,k), kwvrdg=kwvrdg)      
 	else
  		call compute_kwave (ncol, band, lambda_h, ti(:,k), rhoi(:,k), brnt_v(:,k-1), egwdffi(:,k),     &
           	     cp_r, gamma_ad, coriolis_f, inertial_prd, c_speed, ubi(:,k), mom_flux(:,:,k), kwave_level,  &
           	     dtdz(:,k-1), var_t(:,k), k_e(:,k), xi(:,k), k_wave(:,k), lambda_wave(:,:,k)) 
 	endif 

   ENDIF
 ENDDO

 !set variables at model top (k=1) and below 50 km to  zero
  k_wave(:,1)=0._r8
  xi(:,1)=0._r8
  k_e(:,1)=0._r8
  var_t(:,1)=0._r8
  k_wave(:,kwave_level:)=0._r8
  xi(:,kwave_level:)=0._r8
  k_e(:,kwave_level:)=0._r8
  var_t(:,kwave_level:)=0._r8

end subroutine effective_gw_diffusivity

!==========================================================================
subroutine compute_kwave (ncol, band, lambda_h, ti, rhoi, brnt_v, egwdffi,     &
           	     cp_r, gamma_ad, coriolis_f, inertial_prd, c_speed, ubi, mom_flux, kwave_level,  &
           	     dtdz, var_t, k_e, xi, k_wave, lambda_wave, kwvrdg)  

!-----------------------------------------------------------------------
! Compute Var(T') and quantities tht depends on it such as and K_e...
! ....
!-----------------------------------------------------------------------
use gw_common, only: GWBand, pver, pi
use physconst, only: gravit
!------------------------------Arguments--------------------------------
  ! Column dimension.
  integer, intent(in) :: ncol
  ! band of phase speeds c within wich waves are emitted
  type(GWBand), intent(in) :: band
  ! horizonatl wavelength
  real(r8), intent(in) :: lambda_h
  ! Interface temperature.
  real(r8), intent(in) :: ti(ncol)
  ! Interface density (Kg m-3)
  real(r8), intent(in) :: rhoi(ncol)
  ! Interface Brunt-Vaisala frequency.
  !real(r8), intent(in) ::  ni(ncol,pver+1)
  ! Effective gravity wave diffusivity at interfaces.
  real(r8), intent(in) :: egwdffi(ncol)   
  !Coriolis frequency 
  real(r8), intent(in)  :: coriolis_f(:), inertial_prd(:)
  ! Adiabatic lapse rate and R/cp ratio
  real(r8), intent(in) :: gamma_ad, cp_r 
  ! Projection of wind at interfaces.
  real(r8), intent(in) :: ubi(ncol)
  ! The absolute momenum flux computed from tau
  real(r8), intent(in) :: mom_flux(ncol,-band%ngwv:band%ngwv)
  ! Wave phase speeds for each column.
  real(r8), intent(in) :: c_speed(ncol,-band%ngwv:band%ngwv)
  ! Brunt Vaisala frequency
  real(r8), intent(in) :: brnt_v(ncol)   
  ! Environmental pase rate (K/m)
  real(r8), intent(in)  :: dtdz(ncol) 
  ! horizontal wavenumber [anisotropic orography].
  real(r8), intent(in), optional :: kwvrdg(ncol)
 

  real(r8), intent(out) :: var_t(ncol)
  real(r8), intent(out) :: k_e(ncol)
  real(r8), intent(out) :: xi(ncol)
  real(r8), intent(out) :: k_wave(ncol)
  real(r8), intent(out) :: lambda_wave(ncol,-band%ngwv:band%ngwv) 

  !convert degrees to radians
  real(r8), parameter :: degree_radian = pi/180.
  real(r8), dimension (ncol) :: icount, icount_no_w, icount_nonzero
  
  !---------------------------Local storage-------------------------------

  ! Level, wavenumber, constituent and column loop indices.
  integer :: k, l, i, kwave_level
  ! The vertical wavelength and the lmbd_h/lmbd_z ratio
  real(r8) :: lambda_z(ncol,-band%ngwv:band%ngwv) 
  real(r8) :: lambda_ratio(ncol,-band%ngwv:band%ngwv) 
  ! horiz wavelength  [anisotropic orography]
  real(r8) :: lambda_h_rdg(ncol)
  ! GW intrinsic frequency 
  real(r8) :: gw_frq(ncol,-band%ngwv:band%ngwv) 
  ! Vertical wavenumber m
  real(r8) :: m(ncol,-band%ngwv:band%ngwv) 
  ! GW intrinsic phase speed
  real(r8):: c_i(ncol,-band%ngwv:band%ngwv)
  ! GW temperature perturbation
  real(r8):: gw_t(ncol,-band%ngwv:band%ngwv)
  !Characteristic Vertical wavelength
  real(r8):: lmbd_z_star(ncol)
  !Buoyancy vertical wavenumber squared (1/m2)
  real(r8), parameter :: m_b_sq=(2*pi/1000.)**2.	
  !Tunable parameter to bound instability parameter
  real(r8), parameter :: alpha=1./8.
  !Upper and lower limit for normalized temperature variance
  real(r8) :: upper_limit, lower_limit
  ! ubi-c
  real(r8):: ubic(ncol,-band%ngwv:band%ngwv)
  !Temporary values used for calculations locally
  real(r8), dimension(ncol) :: g_NT_sq
  real(r8), dimension(ncol) :: lapse_rate_sq, f_n, & 
			       normalized_varT, one_min_xi	
 		      


!compute gw intrinsic speed, frequency and vertical wavenumber
do i=1,ncol
  do l = -band%ngwv, band%ngwv       
	
         c_i(i,l)=c_speed(i,l)-ubi(i) 

         IF (c_i(i,l) .ne. 0) then
	   gw_frq(i,l)=abs(c_i(i,l))/lambda_h

           if (present(kwvrdg)) then
            m(i,l)= (brnt_v(i)*kwvrdg(i))/gw_frq(i,l)
	   else
            m(i,l)= (brnt_v(i)*band%kwv)/gw_frq(i,l)
	   endif
         ELSE
          !at critical levels where c_i=0 (i.e. c=ubi) tau=0
	  !set everything else to zero too otherwise lateron in the
	  !computation of m we get division by zeros and generation of NaNs and Inf
          gw_frq(i,l)=0._r8  
	  m(i,l)=0._r8
         ENDIF
      
  enddo
enddo

!compute variance of tot temperature perturbation Var(T') = SUM(0.5*T'^2) across whole spectrum 
do i=1,ncol
  var_t(i)=0._r8
  icount(i)=0.
  icount_no_w(i)=0.
  icount_nonzero(i)=0.
  do l = -band%ngwv, band%ngwv

      ! exclude critical levels where c_i=0 and thus gw_freq=0 and m=0
      IF (gw_frq(i,l) .ne. 0._r8) then           
	lambda_z(i,l)= (2.*pi)/m(i,l)

        if (present(kwvrdg)) then
         lambda_h_rdg(i)= (2*pi)/kwvrdg(i)
         lambda_ratio(i,l)=lambda_z(i,l)/lambda_h_rdg(i)
        else
         lambda_ratio(i,l)=lambda_z(i,l)/lambda_h
	endif

	!use MF (m2/s2) to compute T' (K) using the polar eqs and dispersion 
        !rels for mid-freq Gws (see e.g. see Ern et al 2004)
        g_NT_sq(i)= ( gravit/(brnt_v(i)*ti(i)) )**2.
        gw_t(i,l)= ( mom_flux(i,l)/(0.5*lambda_ratio(i,l)*g_NT_sq(i)) )**0.5 ! MF and T' are computed at interfaces (k+1/2)

        !compute Var(T')
        var_t(i)= var_t(i)+ 0.5*gw_t(i,l)**2.
        icount(i)=icount(i) +1
        if (gw_t(i,l) .ne. 0.)then
           icount_nonzero(i)=icount_nonzero(i)+1
        endif
     ELSE !set contribution from waves with gw_freq=0 to total variance to zero
        var_t(i)= var_t(i)+ 0._r8
        icount_no_w(i)=icount_no_w(i)+1
     ENDIF

  enddo
enddo 

 !open(unit=20, file='lat_67S_lon41E_waves')
    !!write (20,*)  'dt, i, l, k, tau, mom_flux, ubi, c, ci, m, gw_t, gwfrq'
 !open(unit=40, file='lat_67S_lon41E_varT')
    !!write (40,*)  'dt, i, k, N, Kzz, var_t, icount_waves, icount_nonzero, icount_no_w'
  !!open(unit=60, file='lat_67S_lon41E_zm')
  !do i=1,ncol
  !   do l = -band%ngwv, band%ngwv
  !     do k = 2, pver
        !!if ( (lat(i) .lt. -60*degree_radian) .and. (lon(i) .lt. 50*degree_radian) ) then
       !if ( (i .eq. 5) .and. (lat(i) .gt. -69*degree_radian .and. lat(i) .lt. -67*degree_radian) .and. & 
          !(lon(i) .gt. 40*degree_radian .and. lon(i) .lt. 42*degree_radian) ) then    
         !if (var_t(i,k) .gt. 0.) then 
	 !write (20,*)  dt/1800., lat(i)*(180./pi), lon(i)*(180./pi), i,l,k, tau(i,l,k), mom_flux(i,l,k), & 
           !            ubi(i,k), c_speed(i,l), c_i(i,l,k), m(i,l,k), gw_t(i,l,k), gw_frq(i,l,k)                  
	  !endif     
        !endif
   !    enddo
   !  enddo 
   !enddo 

 !do i=1,ncol        
 !do k = 2, pver
       !!if ( (lat(i) .lt. -60*degree_radian) .and. (lon(i) .lt. 50*degree_radian) ) then  
 !       if ( (i .eq. 5) .and. (lat(i) .gt. -69*degree_radian .and. lat(i) .lt. -67*degree_radian) .and. & 
 !         (lon(i) .gt. 40*degree_radian .and. lon(i) .lt. 42*degree_radian) ) then 
 !        if (var_t(i,k) .gt. 0.) then    
 !	   write (40,*)  dt/1800., lat(i)*(180./pi), lon(i)*(180./pi), i, k, brnt_v(i,k-1), egwdffi(i,k), var_t(i,k), & 
  !                    icount(i,k), icount_nonzero(i,k), icount_no_w(i,k)
	  !!write (60,*)  dt, k, zm(i,k)
 !        endif
 !      endif
 !   enddo 
 !enddo
  

 !Compute K_e (energy flux due to waves) and xi (instability parameter)
 do i=1,ncol

     lapse_rate_sq(i)= (gamma_ad+dtdz(i))**2. 
     normalized_varT(i)=var_t(i)/lapse_rate_sq(i)
     f_n(i)=1.-(4./3.)*sqrt(coriolis_f(i)/brnt_v(i))

     !impose constraint on normalized temperature varaiance so that 0 < xi < 1
     lower_limit= alpha/2._r8*m_b_sq   
     upper_limit= (alpha/m_b_sq)*(exp((2._r8/alpha) - 0.5) - 0.5)
     if ( (normalized_varT(i) .gt. lower_limit) .and. (normalized_varT(i) .lt. upper_limit) ) then 
      lmbd_z_star(i)=(2._r8*pi)*sqrt( (1._r8/alpha)*normalized_varT(i) + 1/(2._r8*m_b_sq) )
      k_e(i)=normalized_varT(i)*( (4.*f_n(i)*gamma_ad)/ti(i) )*(lmbd_z_star(i)/inertial_prd(i))
      xi(i)=alpha/4. + alpha/2. *log( (m_b_sq/alpha)*normalized_varT(i) + 0.5)

     else
      k_e(i)=0._r8
      xi(i)=0._r8
      var_t(i)=0._r8 !set also variance to zero if not within resonable bounds
     endif     
  enddo

!Finally compute k_wave
   one_min_xi(:) =1.-xi(:)    
   k_wave(:)=(1./one_min_xi(:))*( xi(:)*egwdffi(:)+ & 
                   (cp_r-1.)*k_e(:) )



 !Compute the damping factor (lambda_wave) to define the profile of tau_dmp in the main program
  do l = -band%ngwv, band%ngwv
   ubic(:,l)=ubi(:)-c_speed(:,l)
   lambda_wave(:,l)= (brnt_v(:)**3./(band%kwv*ubic(:,l)**4.))*(k_wave(:)+egwdffi(:))
  enddo



end subroutine compute_kwave

end module gw_chem
  
